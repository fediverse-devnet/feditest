## Prepare

* Arch VM with GUI
* Running UBOS container in a terminal
* Running Geany with the source code
* Small so it can be shared over ZOom

## Run

> feditest -v -v run

  2024-02-17T11:34:56 [INFO] feditest: RUNNING test plan: feditest-default (id: feditest-run-2024-02-17T19:34:56.763087)
  ...
  2024-02-17T11:36:04 [INFO] feditest: End running session: feditest-default/1

Point out from transcript:
* Sets up WordPress + ActivityPub
* Ran some tests against it with the Imp (in-process, scriptable, rudimentary Fediverse implementation)
* Tore it down
* Run same tests against Mastodon

## Test plan

* Why: expense
  * ... of provisioning app instances
  * ... of manually entering data to drive tests when there is not enough scriptability,
    e.g. "now in app Mastodon, follow user @foo@pixelfed.lan"
* Show `feditest-default.json`
  * Two sessions, each with a different constellation of nodes
    * Nodes in a constellation have names, so tests can refer to them
    * Nodes are managed by Node Drivers (more below)
      * Here we use an in-process Imp, and Wordpress / Mastodon Nodes deployed with UBOS
* Can have many test plans to focus in on specific constellations / tests
* Future: auto-generate test plans, edit manually

## Node drivers

* "Server abstraction layer": interfaces `NodeDriver` and `Node`
* `feditest list-nodedrivers`
  * current:
    * in-process Imp
    * UBOS local
  * can be:
    * Docker
    * Linux container
    * cloud
* Tests are defined independently of the Node Driver: can run same test against many applications

## Tests

* `feditest list-tests`
* `feditest info --test <name>`
* CLI with `--help` for non-Python developers

## TestSets

* `feditest list-testsets`
* `feditest info --testset <name>`

## Structure of a test

* Example: `webfinger/test_server_4_4__1_valid_json`:
  * instructs the Node acting as client in the current constellation to perform a
    webfinger query
  * could be automated (e.g. Imp) or manual ("now cause app <name> to perform a webfinger
    query on <identifier>, enter resulting payload here")
* Test uses abstract subtypes of `Node` that go with the protocol being tested, e.g.
  `WebFingerClient` and `WebFingerServer`, `ActivityPubNode`.
* High-level methods that reflect the protocol, e.g. "make actor A follow actor B"
* Implementation depends on:
  * Level of integration between Feditest and the to-be-tested app (automated, manual...)
  * Scriptability of the to-be-tested app

## Where do tests come from?

* Annost
* Use WebFinger example
